\chapter{Introduction}

\emph{``There are only two hard things in Computer Science: cache invalidation and naming things.''} \vspace{-1cm}
\begin{flushright}-- Phil Karlton\end{flushright}

Web applications are becoming more and more dynamic with more personalized content that often requires complex data queries or computations based on large amounts of data. These computations can become a performance bottleneck in the application, which leads to slow response times and poor user experience for the users.

The performance can often be optimized by profiling and analyzing the code behind the computation, but this often not the easiest solution and in some cases the complexity or amount of data used makes it difficult achieve a satisfactory performance. Caching is a popular solution for improving the performance and scalability in these cases since it allows for a simple, scalable and generic way of addressing bottlenecks in the web applications.

Although it sounds like a silver bullet it also places a burden on the programmer that must locate and update the cached values while preserving consistency guarantees. This challenge is for example seen in an outage of the whole Facebook system:

\begin{quote}
  The intent of the automated system is to check for configuration values that are invalid in the cache and replace them with updated values from the persistent store. This works well for a transient problem with the cache, but it doesnâ€™t work when the persistent store is invalid.

 Today we made a change to the persistent copy of a configuration value that was interpreted as invalid. This meant that every single client saw the invalid value and attempted to fix it. Because the fix involves making a query to a cluster of databases, that cluster was quickly overwhelmed by hundreds of thousands of queries a second.
\begin{flushright}Robert Johnson~\cite{facebook_outage}\end{flushright}
\end{quote}

This example shows how critical the caching system can be and the importance of correctness.

This thesis will address this issue by researching the latest caching technique proposed in research and used in practice and contribute with a design and implementation of a caching system in the Python programming language.

\section{Problem}
\label{sec:problem}

Most of the existing caching solutions are based on a pull based caching strategy, where the computation runs and the cached value is stored when the client requests the cached value. After the result has been computed and cached, the client will be presented with the cached value until it has been invalidated.

The pull based caching strategy has the advantage that we only have to cache content that is being used, but it also means that the first time a client asks for the value, it has to wait for the computation to finish. This is not optimal with relation to user experience since the user has to wait in order to be presented with the requested content. To solve this problem we have to precompute the cached values such that the user is presented with content as soon as it is requested.

Besides the performance problem on the initial request, existing caching solutions leaves responsibility for the programmers to maintain the cache in order ensure consistency and an appropriate level of freshness.

These problems with existing caching solutions, presents two major challenges:

\textbf{Cache Management}

The first challenge related to cache management is faced in any caching system, where the programmer has to manage the caching system by naming the cached value and keeping them up to date such that the users are not presented with unexpected content.

One particular challenge within cache management is \emph{cache invalidation} that relies on the programmer correctly identifying every underlying data that affects the given cached value. The programmer then has to declare a way for the cached value to be invalidated when any of the underlying data changes. This analysis is difficult since it require global reasoning about how the underlying data changes in the web application and which computations are cached. Furthermore if the computation behind the cached value is altered to depend on new underlying data, the cache invalidation also has to change, making the cache prone to errors if the latter is forgotten.

We discuss this more in chapter~\ref{chapter:caching} and~\ref{chapter:invalidation}.

\textbf{Data Update Propagation}

The second challenge is related to the task of efficiently keeping the cached values fresh while ensuring the consistency between the cache and the storage system. This challenge will be addressed in chapter~\ref{chapter:data-update-propagation}.

% section problem end

\section{Requirements}
\label{sec:requirements}

The final solution addressing the problems described, will be designed with the following non-functional requirements:

\textbf{Software design:} Must be designed to be maintainable such that the programmer that uses the caching system understands how it works from using it and has the ability to extend it. The design of the system should also be flexible to support multiple storage systems and caches.

\textbf{Adaptability:} Should be convenient and easy to adapt into existing systems. Furthermore the usage of the system should be easy to understand.

\textbf{Efficiency:} Should be efficient with relation to performance such that it does not make existing operations of the systems significantly slower. It should also be efficient with relation to the system load such that it does not use more computational power than necessary to achieve the goal of the system.

\textbf{Scalability:} Should be designed for scalability in the sense that the design should still be efficient for large amount of data and correct when the web application is scaled horizontally.

\textbf{Fault-Tolerance:} Should be designed with considerations on reliability, integrity and maintainability.

% section requirements end

\section{Context}
\label{sec:context}

The problem and requirements are based on a running web applications - the Peergrade.io-platform to ensure that the system is also designed, implemented and tested to be used in practice.

Peergrade.io is a platform for facilitating peer-evaluation in university and high school courses. Currently the platforms serves multiple institutions and thousands of students. One of the key parts of the platform is showing various statistics about the performance of the students in a course. The statistics are based on advanced calculations which take up a large amount of time and needs to be recalculated on small changes to the underlying data.

\section{The Peergrade.io Platform}
\label{sec:the-peergrade-io-platform}

% - User stories:
%   - Teachers have courses, they create assignments and a feedback formular that the students answer to evaluate each other
%   - The students hand in their assignment and afterwards are randomly delegated assignments anonymously that they grade/gives feedback to using the fomular created by the teacher
%   - After the studens have evaluated, the teacher is presented with statistics about the grades the students have given to each other
% - Current technology stack:
%   - Python + Flask + MongoDB + Background Jobs

% section peergrade-io-platform end

% section the-peergrade-io-platform end

\subsection{Running Example}
\label{subsec:running-example}

To relate the solution to a practical example, the thesis will use the following code as a running example:

\begin{figure*}[ht!]
  \input{code/running_example.py}
  \caption{Code with the running example written in Python}
  \label{code:running-example}
\end{figure*}

In this example we have a function \verb$course_score$ that computes the average score in a given course by fetching the participants from the primary data store and through iterations of each participant calculate the average score using the function \verb$participant_score$ that calculates the score of a single participant using a long running external method.

% subsection running-example end


% section context end

\section{Contributions}
\label{sec:contributions}

This thesis addresses challenges described in section~\ref{sec:problem} and requirements in section~\ref{sec:requirements} in the context of a caching system. The result will be a design of a cache system solving those challenges based on the requirements. The design will be implemented in Python  and made available as open source to allow further research and extensions from the implementation. The implementation will therefore also have a focus on delivering a maintainable and tested library.

% TODO: Write in more details what Smache solves

\section{Outline}
\label{sec:outline}

This thesis is structured as following:

With the motivation, problem, and requirements described in this introductory chapter, chapter~\ref{chapter:caching-model} will give an introduction to the basics of caching and present the models used and a set of criteria used to evaluate caching approaches.

The following chapter~\ref{chapter:caching} will describe the existing caching approaches described in literature and used in practice.

Based on the knowledge of existing solution, chapter~\ref{chapter:smache-cachable-functions},~\ref{chapter:invalidation}, and~\ref{chapter:data-update-propagation} describes the solution suggested by this thesis. The solution is explained using the programming model in chapter~\ref{chapter:smache-cachable-functions}. This model is then extended with automatic invalidation in chapter~\ref{chapter:invalidation} and afterwards with in-place updates in chapter~\ref{chapter:data-update-propagation}.

The solution is then evaluated and discussed based on test results and the initial requirements in chapter~\ref{chapter:evaluation}.

Chapter~\ref{chapter:caching-model} introduces caching by presenting the basic caching algorithm, the common architecture of caching system, the models used to describe caching approaches, and criteria used to evaluate caching approaches to find the appropriate technique.

Chapter~\ref{chapter:caching} will describe existing caching approaches with relation to caching evaluation criteria and explain how to choose a caching technique based on these criteria.

Chapter~\ref{chapter:smache-cachable-functions} presents the solution suggested by this thesis for the given context and requirements. First the techniques of existing approaches are discussed and followed by a description of the programming model - cachable functions.

Chapter~\ref{chapter:invalidation} describes in more details how the cachable functions are extended to have automatic invalidations using declared dependencies to underlying data.

Chapter~\ref{chapter:data-update-propagation} explains the data update propagation algorithm used to extend the cachable functions to have in-place cache updates.

Chapter~\ref{chapter:evaluation} goes through the test results related to performance, efficiency, and cache memory usages. The solution are then discussed and evaluated based on the test results and the initial requirements.

Chapter~\ref{chapter:conclusion} finalize the thesis with a conclusion.

% TODO: Write something about the structure of the thesis + Figure illustrating it.

% section outline end


% section contributions end

