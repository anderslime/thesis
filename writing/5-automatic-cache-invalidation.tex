\chapter{Automatic Cache Invalidation}
\label{chapter:invalidation}

In the model for cachable functions described in the previous chapter~\ref{chapter:smache-cachable-functions} we've only described how the system can make a function cachable such that Smache automatically stores and locates the cached object returned by the function. While this removes the burden of naming and localizing cached objects, it does not solve the hard problem of invalidation.

To make cache invalidation easier with Smache, we will extend this solution with an invalidation mechanism that automatically invalidates the cached objects based on dependencies declared by the programmer.

This chapter describes how the suggested system uses the declared dependencies to track updates to underlying data and invalidate cached objects correctly. The solution for automatic invalidation is described in three parts. First we introduce the data structures used to achieve fast and efficient invalidation (section~\ref{sec:simple-object-dependence-graph}). Second, the \emph{dependency registration} describes how the cached objects are registered into the ODG. Finally, the \emph{invalidation propagation algorithm} (section~\ref{sec:invalidation-propagation} describes how Smache invalidates affected cached objects when changes are made to the underlying data. The chapter ends with a discussion on how the suggested solution meets the criteria and requirements of the thesis.

% section dependency-registration end

\section{Simple Object Dependence Graph}
\label{sec:simple-object-dependence-graph}

The Object Dependence Graph (ODG) was first described in a series of papers by IBM~\cite{paper:ibm, paper:ibm-extended} and was build to support the content management system build for the Olympic Games in 2000. The final content served to the user is build from HTML-fragments and HTML-pages editable by the users as well as underlying data periodically changing. To be able to serve the final documents fast, the system pre-generates the HTML pages such that the system doesn't have to generate the pages on each request. To do this efficiently, the system maintains dependencies between the different kinds of objects and updates depending objects when underlying data changes. The pre-generation can also be described in terms of caching, where the system uses an in-place caching approach.

Jim Challenger et.al.~\cite{paper:ibm-extended} presents a simple and a generalized version of the ODG. The generalized version is described for a content management system and includes a number of enhancements compared to the simple model that is unnecessary for the purpose of this thesis. We will therefore use the simple ODG that is described as following:

ODG can be represented using a directed graph, where a vertex either represents underlying data or an object that is a pure transformation of underlying data. An edge from a vertex representing underlying data $u$ to a vertex representing an object $o$ denoted ($u$, $o$) indicates that a change to $u$ also affects $o$.~\cite{paper:ibm-extended} gives the following constraints for the simple ODG:

\begin{itemize}
  \item Each vertex representing underlying data does not have an incoming edge
  \item Each vertex representing an object does not have an outgoing edge
  \item All Vertices in the graph correspond to underlying data (nodes with incoming edges) or objects (nodes with an outgoing edge)
  \item None of the edges have weights associated with them
\end{itemize}

Figure~\ref{fig:simple-odg} illustrates an instance of a simple ODG with four vertices of underlying data ($u_1$, $u_2$, $u_3$ and $u_4$), two vertices representing objects ($o_1$ and $o_2$), and the dependencies between them. Where we can see that when underlying data $u_2$ changes, the system must update both the cached object of $o_1$ and $o_2$ and when $u_4$ changes, it only needs to update $o_2$.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=0.6\linewidth]{figures/simple-odg.pdf}
  \caption{An example instance of a simple ODG}
  \label{fig:simple-odg}
\end{figure*}

% section simple-object-dependence-graph end

\section{Dependency Data Structure for Cachable Functions}
\label{sec:dependency-data-structure-for-cachable-functions}

There exists two representations of the cachable functions. The first one is the static representation, which can be derived directly from the declarations in the source code. This representation only describes dependencies between the declarations and not cached object instances. We will define this representation as the \emph{Declaration Dependence Graph (DDG)}. The other representation is dynamic and describes the dependencies between the entities of the underlying data and the cached object instances. We define this as the \emph{Instance Dependence Graph (IDG)}.

\subsection{Declaration Dependence Graph}
\label{subsec:declaration-dependence-graph}

When the cachable functions are defined as in section~\ref{subsec:making-functions-cachable}, the dependencies are declared using the entity types. The DDG is an extension of the Simple Object Dependence Graph, where the cached functions corresponds to the object vertices and the entity types corresponds to the underlying data. Where the simple ODG only includes direct dependencies, the DDG has two kind of dependencies. An edge from $u$ to $o$ denoted $(u, o)_d$ represents a direct dependency, which means that the dependency defines the given $o$. That is if a given cached object instance has a dependency to an instance of an entity then it cannot change. The direct dependencies includes an index indicating a position such that there is an order of direct dependencies for a given cached object. An edge from $u$ to $o$ denoted $(u, o)_l$ represents a lazy dependency, which means that the dependency can change throughout the lifetime of the cached object instance and has to be evaluated before invalidation to derive the dependency for the instance. This could just as well be two graphs, but we model it as one for illustrative purposes.

Figure~\ref{fig:declaration-dependence-graph} shows the DDG for the running example from code snippet~\ref{code:running-example}. For example we see that the cached object for the \verb$participant_score$-function depends directly on the participant and it depends lazily on the grade. This is because there exists a participant for each score, but the dependencies from a cached object instance to any grade entity can change throughout the lifetime.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=0.6\linewidth]{figures/declaration-dependence-graph.pdf}
  \caption{The Declaration Dependence Graph of the running example}
  \label{fig:declaration-dependence-graph}
\end{figure*}

The DDG graph is represented using two data structures. The lazy dependencies are represented using an outgoing adjacency list from the underlying data nodes. The direct dependencies are represented using an incoming adjacency list from the object nodes ordered by the position index of the dependency. To access a given adjacency list fast we use hash tables index by entity type for the outgoing adjacency list and by the object ID for the incoming adjacency lists as depicted on figure~\ref{fig:ddg-data-structure}.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=0.6\linewidth]{figures/ddg-data-structure.pdf}
  \caption{An illustration of the data structure representing the DDG on figure~\ref{fig:declaration-dependence-graph}}
  \label{fig:ddg-data-structure}
\end{figure*}

New dependencies can be added to the DDG using

\begin{itemize}
  \item \verb$add_dependency(s_id, t_id)$: Adds a dependency between the source id \verb$s_id$ used as index for the hash table and the target id \verb$t_id$ used as element in the adjacency list.
\end{itemize}

When \verb$add_dependency$ is used we check if there already exists an adjacency list in the hash table using \verb$s_id$. If there exists one, we add \verb$t_id$ to the given adjacency list, or else we add a new adjacency list only including \verb$t_id$ and indexed by \verb$s_id$.

The DDG is build by iterating through all the cached functions with their respective dependencies and add the dependencies to the data structure as described above. The lazy dependencies are added with the entity type as \verb$s_id$ and the cached function as \verb$t_id$. The direct dependencies are added using the cached function as \verb$s_id$ and the entity type as \verb$s_id$.  The advantage of the DDG is that it does not change in the lifetime of the application, which means it can be preprocessed when the application starts.

The queries needed for automatic cache invalidation are the following:

\begin{itemize}
  \item \verb$lookup_lazy_dependency(entity_type)$: Finds all lazy dependencies from a given entity type
  \item \verb$lookup_direct_dependency(fun_id)$: Finds all direct dependencies from a given function id
\end{itemize}

Using these data structures we can access a pointer with access to all lazy or direct dependencies using $O(1)$ expected time if we use a hash table using perfect hashing.~\cite{paper:perfect-hashing}. In worst case the space used is the maximum number of edges $O(|u| \cdot |o|)$, where $|u|$ denotes the number of notes representing underlying data and $|o|$ represents the number of nodes representing objects.

% subsection declaration-dependence-graph end

\subsection{Instance Dependence Graph}
\label{subsec:instance-dependence-graph}

The Instance Dependence Graph (IDG) is also an extension of the simple Object Dependence Graph (ODG), where the data entities corresponds to underlying data and the cached object instance generated from the cachable functions corresponds to the objects. An edge from underlying data $u$ to an object $o$ denoted ($u$, $o$) indicates that if $u$ is changed then $o$ must be updated.

The instance dependence graph for the running example is illustrated on figure~\ref{fig:instance-dependence-graph}. In the given example, this graph is quite primitive. It's worth noting that the edges in the IDG are instance specific representations of the direct dependencies of the DDG seen on figure~\ref{fig:declaration-dependence-graph}.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=0.3\linewidth]{figures/instance-dependence-graph.pdf}
  \caption{An example of an Instance Dependence Graph based on the running example}
  \label{fig:instance-dependence-graph}
\end{figure*}

The representation of the IDG is similar to the representation of lazy dependencies for the DDG, where the dependencies are represented using an outgoing adjacency list indexed by a hash table as illustrated on figure~\ref{fig:idg-data-structure}.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=1.0\linewidth]{figures/idg-data-structure.pdf}
  \caption{An illustration of the data structure representing the IDG on figure~\ref{fig:instance-dependence-graph}}
  \label{fig:idg-data-structure}
\end{figure*}

New dependencies are added using \verb$add_dependency$ described for the DDG in section~\ref{subsec:declaration-dependence-graph}, where the entity id is the source and the cached object is the target.

The queries needed for automatic invalidation are:

\begin{itemize}
  \item \verb$lookup_cached_object(entity_id)$: Finds all cached objects depending on the \verb$entity_id$.
\end{itemize}

The DDG uses the same amount of time and space as the DDG described in section~\ref{subsec:instance-dependence-graph}.

% subsection instance-dependence-graph end

% section dependency-management-for-cachable-functions end

\section{Dependency Registration}
\label{sec:dependency-registration}

% TODO: Consider another title name

For the application to know what and when to invalidate, the application must register the dependency declarations and name of cached functions instances. The dependency declarations that defines the lazy and direct dependencies are part of the source code and therefore available when the application is started as illustrated on figure~\ref{fig:declaration-dependency-registration}. This registration flow simply collects all the cached functions registered through the cachable function procedure and adds them as dependencies in the DDG.

The registration of cached object instances happens when the cached object is accessed for the first time as illustrated on figure~\ref{fig:instance-dependency-registration}. In this flow we start by looking up the given cached object in the IDG, but since it's the first time the object is accessed it does not exist. To generate the name of the cached objects we use the ordered direct dependencies from the DDG combined with the input from the request. We derive dependencies to underlying data from the input that represents entities and add dependencies between the given entities and the cached object through the IDG.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=1.0\linewidth]{figures/instance-dependency-registration.pdf}
  \caption{The flow in which cached object instances are accessed when they are accessed the first time}
  \label{fig:instance-dependency-registration}
\end{figure*}

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=1.0\linewidth]{figures/declaration-dependency-registration.pdf}
  \caption{The flow in which lazy and direct dependencies are registered from the declarations}
  \label{fig:declaration-dependency-registration}
\end{figure*}

\section{Invalidation Propagation}
\label{sec:invalidation-propagation}

The purpose of invalidation is to be able to evaluate the freshness of a given cached object and know which cached objects are stale and need to be updated. A cached object is considered stale when it's underlying data has been updated, which happens during the request from a client that involves updating, inserting or deleting data in the primary storage. To be able to react to these events, Smache subscribes to callbacks from the database wrapper. When the database transaction succeeds the database wrapper will notify Smache with the id and type~\footnote{Type is another word for the relation in a relational database and a collection in a document-oriented database} of the manipulated entity. This notification will trigger cache invalidation through Smache.

The cache invalidation consists of three steps:

\begin{enumerate}
  \item Find keys for cached objects that contains the given entity as input
  \item Find keys for cached objects that has a relation dependency to the given entity
  \item Invalidate both set of keys using timestamp invalidation
\end{enumerate}

To trigger invalidations, Smache is notified by the database wrapper with information about which entities are updated. More specifically Smache receives the id of the entity as well as the type of the entity~



% Algorithm:
% - Receive notification about change with entity + type
% - Find keys for cached objects that depend on the given entity:
%   - Either directly through the input
%   - Or through a relation dependency
%     => relation-fun + cached-fun
%     => relation-fun() -> entities
%     => find keys for cached-funs that depends on given entities
% - Invalidate all cached objects given by that key using timestamp invalidation

%  - A request involving changing underlying data
%    => We want to be able to invalidate cached values correctly
%    => We want to do it efficiently (response time should not be affected by cache)
%         - we want to invalidate as soon as possible
%         - the user making changes to data should not wait for invalidation

% TODO: Describe (and visualize) algorithm:
% - what does it do?
% - correctness?
% - time complexity
% - space complexity

% TODO: Consider describing data structure before algorithm

- Operations needed to be supported:
  - When the data is fetched:
    - Lookup cache to see if value is fresh
    - (Computed and) Store cached value
  - When underlying data changes:
    - Find computed functions depending on the given entity instance
      - Both:
        - directly (through arguments)
    - Set cached value as stale
    - Update cached value

% Analyze the queries performed in the algorithm as prequel to the next chapter

\subsection{Invalidation Timestamps}
\label{subsec:invalidation-timestamps}

% TODO: Describe/Discuss how we use invalidation timestamps to avoid the concurrency bug
% This solution is from the IBM
% - Suggested solution to avoid the concurrency bug
%    => Timestamps: primary reason is for the data update propagation, but it allows us to evaluate freshness

% subsection invalidation-timestamps end

\subsection{Database Wrapper Triggers}
\label{subsec:database-wrapper-triggers}

% Trigger Invalidation Through Database Wrapper
% - Discuss the different alternatives and say why we want that

% subsection database-wrapper-triggers end

\section{Implementing Automatic Invalidation}
\label{sec:implementing-automatic-invalidation}

% TODO: Find a place for the implementation:
% - Representation of the ODG
%   - Cache managers are a single point of failure as well as a bottleneck
%   - We use a database for storing information and the library for managing it
%     - Since we represent the data in key-value stores, we can take it further and use the cache to represent it
%     - The cache can only be used if the cache store is available
%     - That means we got no more dependencies
%     - Hash table => Key-value stores in Redis
%     - Data can be sharded to scale
%     - What about transactions?

%   - Static: only changes when new versions of the code base is deployed
%   - Dynamic: changes after deployment - often initiated by changes to the
%              underlying data
%   - Static state is preferred since it it's easier to test and has not 'state'

% section implementing-automatic-invalidation end

\section{Discussion}
\label{sec:invalidation-discussion}

% section discussion end

% - How we do it:
%   - Discuss that the design meets the requirements and criteria stated
% - Implementation:
%   - Extending the API to support automatic cache invalidation

% TODO:
% - Discuss tracking dependencies vs. deriving them as in deploy-time model
%   => With relation to efficiency
%   => The input define the cached object. Another input == another cached object
%     => input deps does not change
%   => The relation dependencies change for a given cached object
%     => Instead of tracking those, we just evaluate them every time

% section existing_solutions_for_cache_invalidation end


% - How it could work:
%   - When calling the cached function (fun instance registration):
%     - When a given computed fun is executed we will serialize the arguments the following way:
%       - Raw values (that can be json) is just serialized into json
%       - Underlying data (entities) are serialized by their entity id and instance id
%     - We can then cache the given value under a unique identifier given by concatenation
%       - A unique id for the fun (python: module + fun name)
%       - The serialized arguments
%     - From the entity arguments we store a reference from the entity instance to the computed fun instance
%       - This is stored in the "dependency graph"
%     - The next time the function is called with the same argument, it will be fetched from the cache
%   - When underlying data changes:
%     - If the data is corresponding to an (entity) argument of the function
%       - We lookup the dependency graph for all the computed funs affected by the entity
%       - These computed funs are then marked as stale and/or written throug/updated
%   - TODO: describe relation updates



% chapter automatic_cache_invalidation end

