\chapter{Automatic Cache Invalidation}
\label{chapter:invalidation}

% Content of this chapter:

% - What is required? (specs whise)
%   - Solve the consistency problem mentioned in figure fig:trigger-based-concurrency-problem
%   -
% - How are existing research doing it?
% - How we do it:
%   - State: prefer static state over dynamic since we can infer the static
%            state from the source code
%   - Invalidation tags?
% - Extending the API to support automatic cache invalidation

\section{Object Dependence Graph}
\label{sec:object-dependence-graph}

% TODO: Write in more details what is up with the IBM solution with relation to
%       automatic invalidation

% section object-dependence-graph end






\section{Existing Solutions For Cache Invalidation}
\label{sec:existing_solutions_for_cache_invalidation}

Map out how the method for doing this (sniffing)

* Sniffing (of the database)
* Invalidation Streams (Transactional Consistency)
* ORM Signals: Using signals from the database wrapper (CacheGenie)
* Static code analysis on SQL-queries: However managing cache consistency does it
* IBM: dependency graph + cache manager + triggers from database

% TODO: Consider moving this detailed section into the approaches


% section existing_solutions_for_cache_invalidation end

\section{Extending Cachable Functions With Automatic Invalidation}
\label{sec:extending_cachable_functions_with_automatic_invalidation}

% TODO: Section where the API is extended with produceres such as relation, source etc.

% section extending_cachable_functions_with_automatic_invalidation end



- Seperate static and dynamic "state"
  - Static: only changes when new versions of the code base is deployed
  - Dynamic: changes after deployment - often initiated by changes to the
             underlying data
  - Static state is preferred since it it's easier to test and has not 'state'

- Static data now:
  - The computed functions:
    - find functions from its id
    - find depending relations from other entities

- Dynamic data now:
  - The dynamic functions:
    - Dependency graph stuff
    - The stored cache elements

- How it could work:
  - When calling the cached function (fun instance registration):
    - When a given computed fun is executed we will serialize the arguments the following way:
      - Raw values (that can be json) is just serialized into json
      - Underlying data (entities) are serialized by their entity id and instance id
    - We can then cache the given value under a unique identifier given by concatenation
      - A unique id for the fun (python: module + fun name)
      - The serialized arguments
    - From the entity arguments we store a reference from the entity instance to the computed fun instance
      - This is stored in the "dependency graph"
    - The next time the function is called with the same argument, it will be fetched from the cache
  - When underlying data changes:
    - If the data is corresponding to an (entity) argument of the function
      - We lookup the dependency graph for all the computed funs affected by the entity
      - These computed funs are then marked as stale and/or written throug/updated
  - TODO: describe relation updates

- Operations needed to be supported:
  - When the data is fetched:
    - Lookup cache to see if value is fresh
    - (Computed and) Store cached value
  - When underlying data changes:
    - Find computed functions depending on the given entity instance
      - Both:
        - directly (through arguments)
        - related (through relations)
    - Set cached value as stale
    - Update cached value

- Data structures introduces:
  - Find affected computed fun instances from given relation
    - Subproblems:
      - Find underlying data identifier from relation instance
        - Done using a relation-function defined by the developer. This
          function is executed every time the query is executed.
      - Find affected for computed fun instances from underlying data identifier and given computed fun
        - Using dictionary (redis) with
          - key: underlying data identtifier
          - value: computed fun identifier
        - Record stored when a new function instance is executed
  - Find affected computed fun instances from direct underlying data
    - Using dictionary (key-value store/redis) with:
      - key: underlying data instance id
      - value: computed fun identifier
    - Record (also) stored when a new function instance is executed

- DS Example:

-- Static dep graph:

prof -\
       score
user -/

prof -\
       hello
user -/

-- Data Structure:
- Given instances:
prof/1 -\
         score/1/2
user/2 -/

prof/1 -\
         hello/1/5
user/5 -/

- Find all funs affected by underlying data:
prof/1 => [score1/2, hello/1/5]
user/2 => [score/1/2]
user/5 => [hello/1/5]

- Find all funs of a given kind affected by underlying data (for relations)
score.prof/1 => [score/1/2]
hello.prof/1 => [hello/1/5]
score.user/2 => [score/1/2]
hello.user/5 => [hello/1/5]

% chapter automatic_cache_invalidation end

